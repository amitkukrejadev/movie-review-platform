// frontend/src/context/AuthContext.jsx
import React, {
  createContext,
  useContext,
  useEffect,
  useState,
  useCallback,
} from "react";

const AuthContext = createContext(null);

export function AuthProvider({ children }) {
  const [user, setUser] = useState(() => {
    try {
      const raw = localStorage.getItem("mrp_user");
      return raw ? JSON.parse(raw) : null;
    } catch {
      return null;
    }
  });
  const [token, setToken] = useState(
    () => localStorage.getItem("mrp_token") || null
  );
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const saveAuth = useCallback((u, t) => {
    setUser(u || null);
    setToken(t || null);
    if (u && t) {
      localStorage.setItem("mrp_user", JSON.stringify(u));
      localStorage.setItem("mrp_token", t);
    } else {
      localStorage.removeItem("mrp_user");
      localStorage.removeItem("mrp_token");
    }
  }, []);

  // login: expects backend POST /api/auth/login { email, password } -> { user, token }
  const login = useCallback(
    async (email, password) => {
      setLoading(true);
      setError(null);
      try {
        const res = await fetch(`/api/auth/login`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ email, password }),
        });
        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          throw new Error(err.message || "Login failed");
        }
        const data = await res.json();
        saveAuth(data.user || null, data.token || null);
        return { ok: true, user: data.user, token: data.token };
      } catch (err) {
        setError(err.message || String(err));
        return { ok: false, error: err.message || String(err) };
      } finally {
        setLoading(false);
      }
    },
    [saveAuth]
  );

  // register: expects POST /api/auth/register { name, email, password } -> { user, token }
  const register = useCallback(
    async (name, email, password) => {
      setLoading(true);
      setError(null);
      try {
        const res = await fetch(`/api/auth/register`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ name, email, password }),
        });
        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          throw new Error(err.message || "Registration failed");
        }
        const data = await res.json();
        saveAuth(data.user || null, data.token || null);
        return { ok: true, user: data.user, token: data.token };
      } catch (err) {
        setError(err.message || String(err));
        return { ok: false, error: err.message || String(err) };
      } finally {
        setLoading(false);
      }
    },
    [saveAuth]
  );

  const logout = useCallback(() => {
    saveAuth(null, null);
  }, [saveAuth]);

  // convenience authenticated fetch which injects Authorization header when token exists
  const authFetch = useCallback(
    async (input, init = {}) => {
      const headers = new Headers(init.headers || {});
      if (token) headers.set("Authorization", `Bearer ${token}`);
      // default JSON headers for non-GET requests
      if (
        !headers.has("Content-Type") &&
        init?.method &&
        init.method !== "GET"
      ) {
        headers.set("Content-Type", "application/json");
      }
      const finalInit = { ...init, headers };
      const res = await fetch(input, finalInit);
      // attempt to parse json always (caller can handle)
      const payload = await res.json().catch(() => null);
      if (!res.ok) {
        const msg = payload?.message || res.statusText || "Request failed";
        const err = new Error(msg);
        err.status = res.status;
        err.payload = payload;
        throw err;
      }
      return payload;
    },
    [token]
  );

  return (
    <AuthContext.Provider
      value={{
        user,
        token,
        loading,
        error,
        login,
        register,
        logout,
        authFetch,
        setUser: saveAuth, // convenience if you want to set both user+token
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const ctx = useContext(AuthContext);
  if (!ctx) throw new Error("useAuth must be used inside AuthProvider");
  return ctx;
}
